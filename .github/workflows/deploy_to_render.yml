name: Deploy Nomi to Render

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: 'The Name of your Nomi'
        required: false
        default: 'Giselle'

jobs:
  deploy-nomi:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Validate Environment Secrets
        env:
          ${{ secrets }}
        run: |
          set -x
          MISSING_VARS=0
          # Check if DISCORD_API_KEY is populated
          if [ -z "${DISCORD_API_KEY:-}" ]; then
            echo "Error: DISCORD_API_KEY is not set or is empty. Please add it to your repository secrets."
            ((MISSING_VARS++)) ||:
          else
            echo "DISCORD_API_KEY is set."
          fi
          # Check if RENDER_API_KEY is populated
          if [ -z "${RENDER_API_KEY:-}" ]; then
            echo "Error: RENDER_API_KEY is not set or is empty. Please add it to your repository secrets."
            ((MISSING_VARS++)) ||:
          else
            echo "RENDER_API_KEY is set."
          fi
          # Check if NOMI_API_KEY is populated
          if [ -z "${NOMI_API_KEY:-}" ]; then
            echo "Error: NOMI_API_KEY is not set or is empty. Please add it to your repository secrets."
            ((MISSING_VARS++)) ||:
          else
            echo "NOMI_API_KEY is set."
          fi
          # Check if NOMI_ID is populated
          if [ -z "${NOMI_ID:-}" ]; then
            echo "Error: NOMI_ID is not set or is empty. Please add it to your repository secrets."
            ((MISSING_VARS++)) ||:
          else
            echo "NOMI_ID is set."
          fi
          exit $MISSING_VARS

      - name: Validate API Keys
        env:
          ${{ secrets }}
        run: |
          set -e
          INVALID_API_KEYS=0
          # Check Render API key is valid
          RESPONSE=$(curl -s -w "%{http_code}" \
            --request GET \
            --header "Authorization: Bearer $RENDER_API_KEY" \
            --header "Accept: application/json" \
            --url "https://api.render.com/v1/services?limit=1")
          HTTP_STATUS="${RESPONSE: -3}"
          RESPONSE_BODY="${RESPONSE::-3}"
          if [ "$HTTP_STATUS" -eq 401 ]; then
            echo "Error: Invalid Render API Key. Authentication failed."
            ((INVALID_API_KEYS++)) ||:
          elif [ "$HTTP_STATUS" -ne 200 ]; then
            echo "Error: Failed to validate Render API Key. HTTP Status: $HTTP_STATUS"
            exit 1
          else
            echo "Render API Key is valid."
          fi

          # Check Nomi API key is valid
          RESPONSE=$(curl -s -w "%{http_code}" \
            --request GET \
            --header "Authorization: $NOMI_API_KEY" \
            --header "Accept: application/json" \
            --url "https://api.nomi.ai/v1/nomis")
          HTTP_STATUS="${RESPONSE: -3}"
          RESPONSE_BODY="${RESPONSE::-3}"
          if [ "$HTTP_STATUS" -eq 400 ]; then
            echo "Error: Invalid Nomi API Key. Authentication failed."
            ((INVALID_API_KEYS++)) ||:
          elif [ "$HTTP_STATUS" -ne 200 ]; then
            echo "Error: Failed to validate Nomi API Key. HTTP Status: $HTTP_STATUS"
            exit 1
          else
            echo "Nomi API Key is valid."
          fi

          # Check Discord API key is valid
          RESPONSE=$(curl -s -w "%{http_code}" \
            --request GET \
            --header "Authorization: Bot $DISCORD_API_KEY" \
            --header "Accept: application/json" \
            --url "https://discord.com/api/v10/users/@me")
          HTTP_STATUS="${RESPONSE: -3}"
          RESPONSE_BODY="${RESPONSE::-3}"
          if [ "$HTTP_STATUS" -eq 400 ]; then
            echo "Error: Invalid Discord API Key. Authentication failed."
            ((INVALID_API_KEYS++)) ||:
          elif [ "$HTTP_STATUS" -ne 200 ]; then
            echo "Error: Failed to validate Discord API Key. HTTP Status: $HTTP_STATUS"
            exit 1
          else
            echo "Discord API Key is valid."
          fi
          exit $INVALID_API_KEYS

      - name: Get Nomi Name from Nomi API
        id: get-nomi-name
        env:
          NOMI_API_KEY: ${{ secrets.NOMI_API_KEY }}
          NOMI_ID: ${{ secrets.NOMI_ID }}
        run: |
          set -e
          # Get Nomi name from Nomi ID
          RESPONSE=$(curl -s -w "%{http_code}" \
            --request GET \
            --header "Authorization: $NOMI_API_KEY" \
            --header "Accept: application/json" \
            --url "https://api.nomi.ai/v1/nomis/$NOMI_ID")
          HTTP_STATUS="${RESPONSE: -3}"
          RESPONSE_BODY="${RESPONSE::-3}"
          if [ "$HTTP_STATUS" -ne 200 ]; then
            echo "Error: Failed to retrieve Nomi Name from Nomi API. HTTP Status: $HTTP_STATUS"
            echo "Response: $RESPONSE_BODY"
            exit 1
          fi
          # Parse the Nomi Name from the response
          echo $RESPONSE_BODY
          NOMI_NAME=$(echo "$RESPONSE_BODY" | jq -r '.name')
          if [ -z "$NOMI_NAME" ] || [ "$NOMI_NAME" == "null" ]; then
            echo "Error: Nomi Name not found in the API response."
            exit 1
          fi
          echo "Successfully retrieved Nomi Name: $NOMI_NAME"
          echo "NOMI_NAME=$NOMI_NAME" >> $GITHUB_OUTPUT

      - name: Normalize Nomi Name
        id: normalize-nomi-name
        env:
          NOMI_NAME: ${{ steps.get-nomi-name.outputs.NOMI_NAME }}
        run: |
          set -e
          if [ -z "$NOMI_NAME" ]; then
            echo "Error: NOMI_NAME is empty."
            exit 1
          fi
          NOMI_NAME_NORMALIZED=$(echo -n "$NOMI_NAME" | iconv -f utf-8 -t ascii//TRANSLIT | tr '[:upper:]' '[:lower:]' | tr -c 'a-z0-9.-' '_')
          if [ -z "$NOMI_NAME_NORMALIZED" ]; then
            echo "Error: Normalized Nomi Name is empty."
            exit 1
          fi
          echo "Normalized Nomi Name: $NOMI_NAME_NORMALIZED"
          echo "NOMI_NAME_NORMALIZED=$NOMI_NAME_NORMALIZED" >> $GITHUB_OUTPUT

      - name: Get Service Name from render.yaml
        id: get-service-name
        run: |
          SERVICE_NAME=$(grep '^\s*name:' render.yaml | sed 's/.*name: *//')
          if [ -z "$SERVICE_NAME" ]; then
            echo "Error: Could not find 'name:' field in render.yaml."
            exit 1
          fi
          echo "Service name: $SERVICE_NAME"
            echo "SERVICE_NAME=$SERVICE_NAME" >> $GITHUB_OUTPUT

      - name: Check for Existing Blueprint
        id: check-existing-blueprint
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          SERVICE_NAME: ${{ steps.get-service-name.outputs.SERVICE_NAME }}
        run: |
          set -e
          # Fetch existing blueprints
          RESPONSE=$(curl -s -w "%{http_code}" \
            --request GET \
            --header "Authorization: Bearer $RENDER_API_KEY" \
            --header "Accept: application/json" \
            --url "https://api.render.com/v1/blueprints")
          HTTP_STATUS="${RESPONSE: -3}"
          RESPONSE_BODY="${RESPONSE::-3}"
          if [ "$HTTP_STATUS" -ne 200 ]; then
            echo "Error: Failed to retrieve blueprints. HTTP Status: $HTTP_STATUS"
            echo "Response: $RESPONSE_BODY"
            exit 1
          fi

          # Check if the response is a valid JSON array
          IS_ARRAY=$(echo "$RESPONSE_BODY" | jq 'type == "array"')
          if [ "$IS_ARRAY" != "true" ]; then
            echo "Error: Expected an array in the response."
            exit 1
          fi

          # Check if any blueprints exist
          BLUEPRINT_COUNT=$(echo "$RESPONSE_BODY" | jq 'length')
          if [ "$BLUEPRINT_COUNT" -eq 0 ]; then
            echo "No existing blueprints found. Please add a blueprint."
            exit 1
          fi

          echo $RESPONSE_BODY

          MATCHES_SERVICE_NAME=$(echo "$RESPONSE_BODY" | jq -c --arg NAME "$SERVICE_NAME" '.[] | select(.blueprint.name == $NAME)')
          echo "$MATCHES_SERVICE_NAME"
          if [ -z "$MATCHES_SERVICE_NAME" ]; then
            echo "No existing blueprints with the name $SERVICE_NAME were found."
            exit 1
          else
            echo "An existing blueprint with the name $SERVICE_NAME was found."
          fi

      - name: Check for Existing Environment Group
        id: check-existing-env-group
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          SERVICE_NAME: ${{ steps.get-service-name.outputs.SERVICE_NAME }}
        run: |
          set -e

          # Fetch existing environment groups
          RESPONSE=$(curl -s -w "%{http_code}" \
            --request GET \
            --header "Authorization: Bearer $RENDER_API_KEY" \
            --header "Accept: application/json" \
            --url "https://api.render.com/v1/env-groups")
          HTTP_STATUS="${RESPONSE: -3}"
          RESPONSE_BODY="${RESPONSE::-3}"
          if [ "$HTTP_STATUS" -ne 200 ]; then
            echo "Error: Failed to retrieve environment groups. HTTP Status: $HTTP_STATUS"
            echo "Response: $RESPONSE_BODY"
            exit 1
          fi

          # Check if the response is a valid JSON array
          IS_ARRAY=$(echo "$RESPONSE_BODY" | jq 'type == "array"')
          if [ "$IS_ARRAY" != "true" ]; then
            echo "Error: Expected an array in the response."
            exit 1
          fi

          # Check if any environment groups exist
          ENV_GROUP_COUNT=$(echo "$RESPONSE_BODY" | jq 'length')
          if [ "$ENV_GROUP_COUNT" -eq 0 ]; then
            echo "No existing environment groups found."
            exit 1
          fi

          # Ensure an environment group that matches our app
          EXISTING_GROUP=$(echo "$RESPONSE_BODY" | jq -r --arg NAME "$SERVICE_NAME" '.[] | select(.envGroup.name == $NAME) | .envGroup')
          if [ -n "$EXISTING_GROUP" ] && [ "$EXISTING_GROUP" != "null" ]; then
            echo "An existing environment group with the name $SERVICE_NAME was found."
            ENV_GROUP_ID=$(echo "$EXISTING_GROUP" | jq -r '.id')
            echo "EXISTING_GROUP_ID=$ENV_GROUP_ID" >> $GITHUB_OUTPUT
            echo "EXISTING_GROUP=true" >> $GITHUB_OUTPUT
          else
            echo "No existing environment groups with the name $SERVICE_NAME were found."
            exit 1
          fi

      - name: Update Environment Variables from GitHub Secrets and nomi.conf
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          ENV_GROUP_ID: ${{ steps.check-existing-env-group.outputs.EXISTING_GROUP_ID }}
          SECRETS: ${{ toJSON(secrets) }}
        run: |
          set -e

          # Read nomi.conf file and convert to JSON object
          CONF_JSON="{}"
          if [ -f setup/nomi.conf ]; then
            while IFS='=' read -r KEY VALUE; do
              # Skip lines that are empty or start with a comment
              if [[ -z "$KEY" || "$KEY" =~ ^# ]]; then
                continue
              fi
              KEY=$(echo "$KEY" | xargs)   # Trim whitespace
              VALUE=$(echo "$VALUE" | xargs) # Trim whitespace
              # Add key-value pair to CONF_JSON using jq
              CONF_JSON=$(echo "$CONF_JSON" | jq --arg KEY "$KEY" --arg VALUE "$VALUE" '.[$KEY] = $VALUE')
            done < setup/nomi.conf
          else
            echo "The file 'nomi.conf' was not found"
            exit 1
          fi

          # Merge nomi.conf values first, then let secrets override them
          MERGED=$(echo "$CONF_JSON" | jq --argjson secrets "$SECRETS" '. * $secrets')

          ENV_VARS=$(echo "$SECRETS" | jq -r 'keys[]')

          for KEY in $ENV_VARS; do
            if [[ $KEY == "github_token" || $KEY == "RENDER_API_KEY" ]]; then
              continue
            fi
            # URL-encode the KEY
            ENCODED_KEY=$(printf '%s' "$KEY" | jq -sRr @uri)

            # Ensure the value is properly escaped for JSON
            VALUE=$(echo "$SECRETS" | jq -r --arg KEY "$KEY" '.[$KEY]')
            VALUE_ESCAPED=$(printf '%s' "$VALUE" | jq -Rs '.')

            RESPONSE=$(curl -s -w "%{http_code}" \
              --request PUT \
              --header "Authorization: Bearer $RENDER_API_KEY" \
              --header "Accept: application/json" \
              --header "Content-Type: application/json" \
              --data "{\"value\":$VALUE_ESCAPED}" \
              --url "https://api.render.com/v1/env-groups/$ENV_GROUP_ID/env-vars/$ENCODED_KEY")
            HTTP_STATUS="${RESPONSE: -3}"
            RESPONSE_BODY="${RESPONSE::-3}"
            if [ "$HTTP_STATUS" -ne 200 ]; then
              echo "Error: Failed to update env var $KEY. HTTP Status: $HTTP_STATUS"
              echo "Response: $RESPONSE_BODY"
              exit 1
            fi
            echo "Successfully updated env var $KEY."
          done

      # - name: Update Environment Variables from GitHub Secrets
      #   env:
      #     SECRETS: ${{ toJSON(secrets) }}
      #     ENV_GROUP_ID: ${{ steps.check-existing-env-group.outputs.EXISTING_GROUP_ID }}
      #   run: |
      #     set -e

      #     SECRETS_KEYS=$(echo "$SECRETS" | jq -r 'keys[]')

      #     for KEY in $SECRETS_KEYS; do
      #       # URL-encode the KEY
      #       ENCODED_KEY=$(printf '%s' "$KEY" | jq -sRr @uri)

      #       # Ensure the value is properly escaped for JSON
      #       VALUE=$(echo "$SECRETS" | jq -r --arg KEY "$KEY" '.[$KEY]')
      #       VALUE_ESCAPED=$(printf '%s' "$VALUE" | jq -Rs '.')

      #       RESPONSE=$(curl -s -w "%{http_code}" \
      #         --request PUT \
      #         --header "Authorization: Bearer $RENDER_API_KEY" \
      #         --header "Content-Type: application/json" \
      #         --data "{\"value\":$VALUE_ESCAPED}" \
      #         --url "https://api.render.com/v1/env-groups/$ENV_GROUP_ID/env-vars/$ENCODED_KEY")
      #       HTTP_STATUS="${RESPONSE: -3}"
      #       RESPONSE_BODY="${RESPONSE::-3}"
      #       if [ "$HTTP_STATUS" -ne 200 ]; then
      #         echo "Error: Failed to update env var $KEY. HTTP Status: $HTTP_STATUS"
      #         echo "Response: $RESPONSE_BODY"
      #         exit 1
      #       fi
      #       echo "Successfully updated env var $KEY."
      #     done

      - name: Get Last Workflow Run
        id: get-last-run
        if: steps.check-existing-deployment.outputs.EXISTING_DEPLOYMENT == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          WORKFLOW_ID: ${{ github.workflow }}
          BRANCH: ${{ github.ref_name }}
          CURRENT_RUN_ID: ${{ github.run_id }}
        run: |
          set -e
          # Get the workflow runs for this workflow and branch
          RESPONSE=$(curl -s \
            --request GET \
            --header "Authorization: Bearer $GITHUB_TOKEN" \
            --url "https://api.github.com/repos/${{ github.repository }}/actions/workflows/${{ github.workflow }}/runs?branch=${{ github.ref_name }}&status=completed&per_page=5")
          # Parse the runs and find the last run before the current one
          LAST_RUN_TIME=""
          RUNS=$(echo "$RESPONSE" | jq -c '.workflow_runs[]')
          for run in $RUNS; do
            RUN_ID=$(echo "$run" | jq -r '.id')
            if [ "$RUN_ID" -ne "${{ github.run_id }}" ]; then
              LAST_RUN_TIME=$(echo "$run" | jq -r '.updated_at')
              LAST_RUN_STATUS=$(echo "$run" | jq -r '.conclusion')
              break
            fi
          done
          if [ -z "$LAST_RUN_TIME" ]; then
            echo "No previous workflow run found."
            echo "::set-output name=OVERWRITE_ALLOWED::false"
            exit 0
          fi
          # Convert times to seconds since epoch
          LAST_RUN_TIMESTAMP=$(date -d "$LAST_RUN_TIME" +%s)
          CURRENT_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          CURRENT_TIMESTAMP=$(date -d "$CURRENT_TIME" +%s)
          TIME_DIFF=$(( CURRENT_TIMESTAMP - LAST_RUN_TIMESTAMP ))
          if [ "$TIME_DIFF" -lt 30 ]; then
            echo "The last workflow run was $TIME_DIFF seconds ago."
            echo "::set-output name=OVERWRITE_ALLOWED::true"
          else
            echo "The last workflow run was more than 30 seconds ago."
            echo "::set-output name=OVERWRITE_ALLOWED::false"
          fi
