name: Deploy Nomi to Render

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'The Name of your Nomi'
        required: true
        default: ''

jobs:
  deploy-nomi:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      # - name: Validate Nomi AI API Key
      #   env:
      #     NOMI_API_KEY: ${{ secrets.NOMI_API_KEY }}
      #   run: |
      #     set -e
      #     # Check if NOMI_API_KEY is populated
      #     if [ -z "$NOMI_API_KEY" ]; then
      #       echo "Error: NOMI_API_KEY is not set or is empty. Please add it to your repository secrets."
      #       exit 1
      #     fi

      #     # Check key is valid
      #     response=$(curl -s -w "%{http_code}" \
      #       --request GET \
      #       --header "accept: application/json" \
      #       --header "Authorization: $NOMI_API_KEY" \
      #       --header "Accept: application/json" \
      #       --url "https://api.nomi.ai/v1/nomis")
      #     http_status="${response: -3}"
      #     response_body="${response::-3}"
      #     if [ "$http_status" -eq 400 ]; then
      #       echo "Error: Invalid Nomi AI API Key. Authentication failed."
      #       exit 1
      #     elif [ "$http_status" -ne 200 ]; then
      #       echo "Error: Failed to validate Nomi AI API Key. HTTP Status: $http_status"
      #       exit 1
      #     else
      #       echo "Nomi AI API Key is valid."
      #     fi

      - name: Validate Render API Key
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
        run: |
          set -e
          # Check if RENDER_API_KEY is populated
          if [ -z "$RENDER_API_KEY" ]; then
            echo "Error: RENDER_API_KEY is not set or is empty. Please add it to your repository secrets."
            exit 1
          fi

          # Check key is valid
          response=$(curl -s -w "%{http_code}" \
            --request GET \
            --header "accept: application/json" \
            --header "Authorization: Bearer $RENDER_API_KEY" \
            --header "Accept: application/json" \
            --url "https://api.render.com/v1/services?limit=1")
          http_status="${response: -3}"
          response_body="${response::-3}"
          if [ "$http_status" -eq 401 ]; then
            echo "Error: Invalid Render.com API Key. Authentication failed."
            exit 1
          elif [ "$http_status" -ne 200 ]; then
            echo "Error: Failed to validate Render.com API Key. HTTP Status: $http_status"
            exit 1
          else
            echo "Render.com API Key is valid."
          fi

      - name: Get Service Name from render.yaml
        id: get-service-name
        run: |
          SERVICE_NAME=$(grep '^\s*name:' render.yaml | sed 's/.*name: *//')
          if [ -z "$SERVICE_NAME" ]; then
            echo "Error: Could not find 'name:' field in render.yaml."
            exit 1
          fi
          echo "Service name: $SERVICE_NAME"
            echo "SERVICE_NAME=$SERVICE_NAME" >> $GITHUB_OUTPUT  

      - name: Check for Existing Blueprint
        id: check-existing-blueprint
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
        run: |
          set -e

          # Fetch existing blueprints
          response=$(curl -s -w "%{http_code}" \
            --request GET \
            --header "accept: application/json" \
            --header "Authorization: Bearer $RENDER_API_KEY" \
            --header "Accept: application/json" \
            --url "https://api.render.com/v1/blueprints")
          http_status="${response: -3}"
          response_body="${response::-3}"
          if [ "$http_status" -ne 200 ]; then
            echo "Error: Failed to retrieve blueprints. HTTP Status: $http_status"
            echo "Response: $response_body"
            exit 1
          fi

          # Check if the response is a valid JSON array
          IS_ARRAY=$(echo "$response_body" | jq 'type == "array"')
          if [ "$IS_ARRAY" != "true" ]; then
            echo "Error: Expected an array in the response."
            exit 1
          fi

          # Check if any blueprints exist
          BLUEPRINT_COUNT=$(echo "$response_body" | jq 'length')
          if [ "$BLUEPRINT_COUNT" -eq 0 ]; then
            echo "No existing blueprints found. Please add a blueprint."
            exit 1
          fi

      - name: Check for Existing Environment Group
        id: check-existing-env-group
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          SERVICE_NAME: ${{ steps.get-service-name.outputs.SERVICE_NAME }}
        run: |
          set -e

          # Fetch existing environment groups
          response=$(curl -s -w "%{http_code}" \
            --request GET \
            --header "accept: application/json" \
            --header "Authorization: Bearer $RENDER_API_KEY" \
            --header "Accept: application/json" \
            --url "https://api.render.com/v1/env-groups")
          http_status="${response: -3}"
          response_body="${response::-3}"
          if [ "$http_status" -ne 200 ]; then
            echo "Error: Failed to retrieve environment groups. HTTP Status: $http_status"
            echo "Response: $response_body"
            exit 1
          fi

          # Check if the response is a valid JSON array
          IS_ARRAY=$(echo "$response_body" | jq 'type == "array"')
          if [ "$IS_ARRAY" != "true" ]; then
            echo "Error: Expected an array in the response."
            exit 1
          fi

          # Check if any environment groups exist
          ENV_GROUP_COUNT=$(echo "$response_body" | jq 'length')
          if [ "$ENV_GROUP_COUNT" -eq 0 ]; then
            echo "No existing environment groups found."
            exit 1
          fi

          # Ensure an environment group that matches our app   
          EXISTING_GROUP=$(echo "$response_body" | jq -r --arg NAME "$SERVICE_NAME" '.[] | select(.envGroup.name == $NAME) | .envGroup')
          if [ -n "$EXISTING_GROUP" ] && [ "$EXISTING_GROUP" != "null" ]; then
            echo "An existing environment group with the name $SERVICE_NAME was found."
            ENV_GROUP_ID=$(echo "$EXISTING_GROUP" | jq -r '.id')
            echo "EXISTING_GROUP_ID=$ENV_GROUP_ID" >> $GITHUB_OUTPUT
            echo "EXISTING_GROUP=true" >> $GITHUB_OUTPUT
          else
            echo "No existing environment groups with the name $SERVICE_NAME was found."
            exit 1
          fi
          
      - name: Check and Update Environment Variables in Env Group
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          ENV_GROUP_ID: ${{ steps.check-existing-env-group.outputs.EXISTING_GROUP_ID }}
        run: |
          # set -e
          set -x          
      
          # Retrieve the existing env group
          RESPONSE=$(curl -s \
            --request GET \
            --header "accept: application/json" \
            --header "Authorization: Bearer $RENDER_API_KEY" \
            --header "Accept: application/json" \
            --url "https://api.render.com/v1/env-groups/$ENV_GROUP_ID")
      
          # Parse the envVars array
          ENV_VARS=$(echo "$RESPONSE" | jq -r '.envVars[].key')
      
          # Initialize a variable to track missing secrets
          MISSING_SECRETS=()
      
          # Iterate over each env var key
          for KEY in $ENV_VARS; do
            # Get the value from the environment variable (set from secrets)
            VALUE=$(printenv "$KEY")
            if [ -z "$VALUE" ]; then
              echo "Error: No secret found for environment variable $KEY."
              MISSING_SECRETS+=("$KEY")
              continue
            fi

            # After processing all env vars, check if there were any missing secrets
            if [ ${#MISSING_SECRETS[@]} -ne 0 ]; then
              echo "The following environment variables were not updated due to missing secrets:"
              for KEY in "${MISSING_SECRETS[@]}"; do
                echo "- $KEY"
              done
              exit 1
            fi
      
            # Update the env var in the env group

            # URL-encode the KEY
            ENCODED_KEY=$(printf '%s' "$KEY" | jq -sRr @uri)

            # Ensure the value is properly escaped for JSON
            VALUE_ESCAPED=$(printf '%s' "$VALUE" | jq -Rs '.')

            UPDATE_RESPONSE=$(curl -s -w "%{http_code}" \
              --request PUT \
              --header "accept: application/json" \
              --header "Authorization: Bearer $RENDER_API_KEY" \
              --header "Content-Type: application/json" \
              --data "{\"value\":$VALUE_ESCAPED}" \
              --url "https://api.render.com/v1/env-groups/$ENV_GROUP_ID/env-vars/$ENCODED_KEY")
            HTTP_STATUS="${UPDATE_RESPONSE: -3}"
            RESPONSE_BODY="${UPDATE_RESPONSE::-3}"
            if [ "$HTTP_STATUS" -ne 200 ]; then
              echo "Error: Failed to update env var $KEY. HTTP Status: $HTTP_STATUS"
              echo "Response: $RESPONSE_BODY"
              exit 1
            fi
            echo "Successfully updated env var $KEY."
          done
      
      - name: exit
        run: |
          exit 1              


      - name: Get Last Workflow Run
        id: get-last-run
        if: steps.check-existing-deployment.outputs.EXISTING_DEPLOYMENT == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          WORKFLOW_ID: ${{ github.workflow }}
          BRANCH: ${{ github.ref_name }}
          CURRENT_RUN_ID: ${{ github.run_id }}
        run: |
          set -e
          # Get the workflow runs for this workflow and branch
          RESPONSE=$(curl -s \
            --request GET \
            --header "Authorization: Bearer $GITHUB_TOKEN" \
            --url "https://api.github.com/repos/${{ github.repository }}/actions/workflows/${{ github.workflow }}/runs?branch=${{ github.ref_name }}&status=completed&per_page=5")
          # Parse the runs and find the last run before the current one
          LAST_RUN_TIME=""
          RUNS=$(echo "$RESPONSE" | jq -c '.workflow_runs[]')
          for run in $RUNS; do
            RUN_ID=$(echo "$run" | jq -r '.id')
            if [ "$RUN_ID" -ne "${{ github.run_id }}" ]; then
              LAST_RUN_TIME=$(echo "$run" | jq -r '.updated_at')
              LAST_RUN_STATUS=$(echo "$run" | jq -r '.conclusion')
              break
            fi
          done
          if [ -z "$LAST_RUN_TIME" ]; then
            echo "No previous workflow run found."
            echo "::set-output name=OVERWRITE_ALLOWED::false"
            exit 0
          fi
          # Convert times to seconds since epoch
          LAST_RUN_TIMESTAMP=$(date -d "$LAST_RUN_TIME" +%s)
          CURRENT_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          CURRENT_TIMESTAMP=$(date -d "$CURRENT_TIME" +%s)
          TIME_DIFF=$(( CURRENT_TIMESTAMP - LAST_RUN_TIMESTAMP ))
          if [ "$TIME_DIFF" -lt 30 ]; then
            echo "The last workflow run was $TIME_DIFF seconds ago."
            echo "::set-output name=OVERWRITE_ALLOWED::true"
          else
            echo "The last workflow run was more than 30 seconds ago."
            echo "::set-output name=OVERWRITE_ALLOWED::false"
          fi          

      - name: Get Nomi Name from Nomi AI API
        env:
          NOMI_ID: ${{ secrets.NOMI_ID }}
          NOMI_API_KEY: ${{ secrets.NOMI_API_KEY }}
        run: |
          set -e  # Exit immediately if a command exits with a non-zero status
          # Make API call to Nomi AI
          response=$(curl -s -w "%{http_code}" \
            --request GET \
            --header "Authorization: $NOMI_API_KEY" \
            --header "Accept: application/json" \
            --url "https://api.nomi.ai/v1/nomis/$NOMI_ID")
          http_status="${response: -3}"
          response_body="${response::-3}"
          if [ "$http_status" -ne 200 ]; then
            echo "Error: Failed to retrieve Nomi Name from Nomi AI API. HTTP Status: $http_status"
            echo "Response: $response_body"
            exit 1
          fi
          # Parse the Nomi Name from the response
          NOMI_NAME=$(echo "$response_body" | jq -r '.name')
          if [ -z "$NOMI_NAME" ] || [ "$NOMI_NAME" == "null" ]; then
            echo "Error: Nomi Name not found in the API response."
            exit 1
          fi
          echo "Successfully retrieved Nomi Name: $NOMI_NAME"
          echo "NOMI_NAME=$NOMI_NAME" >> $GITHUB_ENV

      - name: Normalize Nomi Name
        run: |
          set -e
          if [ -z "$NOMI_NAME" ]; then
            echo "Error: NOMI_NAME is empty."
            exit 1
          fi
          NOMI_NAME_NORMALIZED=$(echo -n "$NOMI_NAME" | tr '[:upper:]' '[:lower:]' | tr -c 'a-z0-9.-' '_' | sed 's/_*$//')
          if [ -z "$NOMI_NAME_NORMALIZED" ]; then
            echo "Error: Normalized Nomi Name is empty."
            exit 1
          fi
          echo "Normalized Nomi Name: $NOMI_NAME_NORMALIZED"
          echo "NOMI_NAME_NORMALIZED=$NOMI_NAME_NORMALIZED" >> $GITHUB_ENV
