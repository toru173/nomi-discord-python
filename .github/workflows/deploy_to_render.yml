name: Deploy Nomi to Render

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'The Name of your Nomi'
        required: true
        default: ''

jobs:
  deploy-nomi:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Validate Environment Secrets
        env:
          ${{ secrets }}
        run: |
          set -e
          MISSING_VARS=0
          # Check if RENDER_API_KEY is populated
          if [ -z "$RENDER_API_KEY" ]; then
            echo "Error: DISCORD_API_KEY is not set or is empty. Please add it to your repository secrets."
            $MISSING_VARS+=1
          else
            echo "DISCORD_API_KEY is set."
          fi
          # Check if RENDER_API_KEY is populated
          if [ -z "$RENDER_API_KEY" ]; then
            echo "Error: RENDER_API_KEY is not set or is empty. Please add it to your repository secrets."
            $MISSING_VARS+=1
          else
            echo "RENDER_API_KEY is set."
          fi
          # Check if NOMI_API_KEY is populated
          if [ -z "$NOMI_API_KEY" ]; then
            echo "Error: NOMI_API_KEY is not set or is empty. Please add it to your repository secrets."
            $MISSING_VARS+=1
          else
            echo "NOMI_API_KEY is set."
          fi
          # Check if NOMI_ID is populated
          if [ -z "$NOMI_ID" ]; then
            echo "Error: NOMI_ID is not set or is empty. Please add it to your repository secrets."
            $MISSING_VARS+=1
          else
            echo "NOMI_ID is set."
          fi
          exit $MISSING_VARS

      - name: Validate API Keys
        env:
          ${{ secrets }}
        run: |
          set -e
          INVALID_API_KEYS=0
          # Check Render API key is valid
          response=$(curl -s -w "%{http_code}" \
            --request GET \
            --header "Authorization: Bearer $RENDER_API_KEY" \
            --header "Accept: application/json" \
            --url "https://api.render.com/v1/services?limit=1")
          http_status="${response: -3}"
          response_body="${response::-3}"
          if [ "$http_status" -eq 401 ]; then
            echo "Error: Invalid Render API Key. Authentication failed."
            $INVALID_API_KEYS+=1
          elif [ "$http_status" -ne 200 ]; then
            echo "Error: Failed to validate Render API Key. HTTP Status: $http_status"
            exit 1
          else
            echo "Render API Key is valid."
          fi

          # Check Nomi API key is valid
          response=$(curl -s -w "%{http_code}" \
            --request GET \
            --header "Authorization: $NOMI_API_KEY" \
            --header "Accept: application/json" \
            --url "https://api.nomi.ai/v1/nomis")
          http_status="${response: -3}"
          response_body="${response::-3}"
          if [ "$http_status" -eq 400 ]; then
            echo "Error: Invalid Nomi API Key. Authentication failed."
            $INVALID_API_KEYS+=1
          elif [ "$http_status" -ne 200 ]; then
            echo "Error: Failed to validate Nomi API Key. HTTP Status: $http_status"
            exit 1
          else
            echo "Nomi API Key is valid."
          fi

          # Check Discord API key is valid
          response=$(curl -s -w "%{http_code}" \
            --request GET \
            --header "Authorization: Bot $DISCORD_API_KEY" \
            --header "Accept: application/json" \
            --url "https://discord.com/api/v10/users/@me")
          http_status="${response: -3}"
          response_body="${response::-3}"
          if [ "$http_status" -eq 400 ]; then
            echo "Error: Invalid Discord API Key. Authentication failed."
            $INVALID_API_KEYS+=1
          elif [ "$http_status" -ne 200 ]; then
            echo "Error: Failed to validate Discord API Key. HTTP Status: $http_status"
            exit 1
          else
            echo "Discord API Key is valid."
          fi
          exit $INVALID_API_KEYS

      - name: Get Nomi Name from Nomi AI API
        env:
          ${{ secrets }}
        run: |
          set -e
          # Get Nomi name from Nomi ID
          response=$(curl -s -w "%{http_code}" \
            --request GET \
            --header "Authorization: $NOMI_API_KEY" \
            --header "Accept: application/json" \
            --url "https://api.nomi.ai/v1/nomis/$NOMI_ID")
          http_status="${response: -3}"
          response_body="${response::-3}"
          if [ "$http_status" -ne 200 ]; then
            echo "Error: Failed to retrieve Nomi Name from Nomi API. HTTP Status: $http_status"
            echo "Response: $response_body"
            exit 1
          fi
          # Parse the Nomi Name from the response
          NOMI_NAME=$(echo "$response_body" | jq -r '.name')
          if [ -z "$NOMI_NAME" ] || [ "$NOMI_NAME" == "null" ]; then
            echo "Error: Nomi Name not found in the API response."
            exit 1
          fi
          echo "Successfully retrieved Nomi Name: $NOMI_NAME"
          echo "NOMI_NAME=$NOMI_NAME" >> $GITHUB_ENV

      - name: Normalize Nomi Name
        run: |
          set -e
          if [ -z "$NOMI_NAME" ]; then
            echo "Error: NOMI_NAME is empty."
            exit 1
          fi
          NOMI_NAME_NORMALIZED=$(echo -n "$NOMI_NAME" | iconv -f utf-8 -t ascii//TRANSLIT | tr '[:upper:]' '[:lower:]' | tr -c 'a-z0-9.-' '_')
          if [ -z "$NOMI_NAME_NORMALIZED" ]; then
            echo "Error: Normalized Nomi Name is empty."
            exit 1
          fi
          echo "Normalized Nomi Name: $NOMI_NAME_NORMALIZED"
          echo "NOMI_NAME_NORMALIZED=$NOMI_NAME_NORMALIZED" >> $GITHUB_ENV

      - name: Get Service Name from render.yaml
        id: get-service-name
        run: |
          SERVICE_NAME=$(grep '^\s*name:' render.yaml | sed 's/.*name: *//')
          if [ -z "$SERVICE_NAME" ]; then
            echo "Error: Could not find 'name:' field in render.yaml."
            exit 1
          fi
          echo "Service name: $SERVICE_NAME"
            echo "SERVICE_NAME=$SERVICE_NAME" >> $GITHUB_OUTPUT

      - name: Check for Existing Blueprint
        id: check-existing-blueprint
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          SERVICE_NAME: ${{ steps.get-service-name.outputs.SERVICE_NAME }}
        run: |
          set -e
          # Fetch existing blueprints
          response=$(curl -s -w "%{http_code}" \
            --request GET \
            --header "Authorization: Bearer $RENDER_API_KEY" \
            --header "Accept: application/json" \
            --url "https://api.render.com/v1/blueprints")
          http_status="${response: -3}"
          response_body="${response::-3}"
          if [ "$http_status" -ne 200 ]; then
            echo "Error: Failed to retrieve blueprints. HTTP Status: $http_status"
            echo "Response: $response_body"
            exit 1
          fi

          # Check if the response is a valid JSON array
          IS_ARRAY=$(echo "$response_body" | jq 'type == "array"')
          if [ "$IS_ARRAY" != "true" ]; then
            echo "Error: Expected an array in the response."
            exit 1
          fi

          # Check if any blueprints exist
          BLUEPRINT_COUNT=$(echo "$response_body" | jq 'length')
          if [ "$BLUEPRINT_COUNT" -eq 0 ]; then
            echo "No existing blueprints found. Please add a blueprint."
            exit 1
          fi

          MATCHES_SERVICE_NAME=$(echo "$response_body" | jq '.[] | select(.blueprint.name == "nomi-discord-python")')
          echo $MATCHES_SERVICE_NAME
          if [ -z "$MATCHES_SERVICE_NAME" ]; then
            echo "No existing blueprints with the name $SERVICE_NAME were found."
            exit 1
          fi



      - name: Check for Existing Environment Group
        id: check-existing-env-group
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          SERVICE_NAME: ${{ steps.get-service-name.outputs.SERVICE_NAME }}
        run: |
          set -e

          # Fetch existing environment groups
          response=$(curl -s -w "%{http_code}" \
            --request GET \
            --header "Authorization: Bearer $RENDER_API_KEY" \
            --header "Accept: application/json" \
            --url "https://api.render.com/v1/env-groups")
          http_status="${response: -3}"
          response_body="${response::-3}"
          if [ "$http_status" -ne 200 ]; then
            echo "Error: Failed to retrieve environment groups. HTTP Status: $http_status"
            echo "Response: $response_body"
            exit 1
          fi

          # Check if the response is a valid JSON array
          IS_ARRAY=$(echo "$response_body" | jq 'type == "array"')
          if [ "$IS_ARRAY" != "true" ]; then
            echo "Error: Expected an array in the response."
            exit 1
          fi

          # Check if any environment groups exist
          ENV_GROUP_COUNT=$(echo "$response_body" | jq 'length')
          if [ "$ENV_GROUP_COUNT" -eq 0 ]; then
            echo "No existing environment groups found."
            exit 1
          fi

          # Ensure an environment group that matches our app
          EXISTING_GROUP=$(echo "$response_body" | jq -r --arg NAME "$SERVICE_NAME" '.[] | select(.envGroup.name == $NAME) | .envGroup')
          if [ -n "$EXISTING_GROUP" ] && [ "$EXISTING_GROUP" != "null" ]; then
            echo "An existing environment group with the name $SERVICE_NAME was found."
            ENV_GROUP_ID=$(echo "$EXISTING_GROUP" | jq -r '.id')
            echo "EXISTING_GROUP_ID=$ENV_GROUP_ID" >> $GITHUB_OUTPUT
            echo "EXISTING_GROUP=true" >> $GITHUB_OUTPUT
          else
            echo "No existing environment groups with the name $SERVICE_NAME were found."
            exit 1
          fi

      - name: Update Environment Variables from GitHub Secrets
        env:
          # All Secrets need to be expressed as environment variables
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          NOMI_API_KEY: ${{ secrets.NOMI_API_KEY }}
          DISCORD_API_KEY: ${{ secrets.DISCORD_API_KEY }}

          # This isn't a secret, so isn't masked
          ENV_GROUP_ID: ${{ steps.check-existing-env-group.outputs.EXISTING_GROUP_ID }}
        run: |
          set -e

          # Retrieve the existing env group
          RESPONSE=$(curl -s \
            --request GET \
            --header "Authorization: Bearer $RENDER_API_KEY" \
            --header "Accept: application/json" \
            --url "https://api.render.com/v1/env-groups/$ENV_GROUP_ID")

          # Parse the envVars array
          ENV_VARS=$(echo "$RESPONSE" | jq -r '.envVars[].key')

          MISSING_SECRETS=()

          # Iterate over each env var key
          for KEY in $ENV_VARS; do
            # Get the value from the environment variable (set from secrets)
            VALUE="${!KEY:-}"
            if [ -z "$VALUE" ]; then
              echo "Error: No secret found for Render environment variable $KEY."
              MISSING_SECRETS+=("$KEY")
              continue
            fi
          done

          # After processing all env vars, check if there were any missing secrets
          if [ ${#MISSING_SECRETS[@]} -ne 0 ]; then
            echo "The following Render environment variables were not updated due to missing secrets:"
            for KEY in "${MISSING_SECRETS[@]}"; do
              echo "- $KEY"
            done
            exit 1
          fi

          # We have all the secrets we need. Update the env vars in the env group
          for KEY in $ENV_VARS; do
            # URL-encode the KEY
            ENCODED_KEY=$(printf '%s' "$KEY" | jq -sRr @uri)

            # Ensure the value is properly escaped for JSON
            VALUE_ESCAPED=$(printf '%s' "$VALUE" | jq -Rs '.')

            UPDATE_RESPONSE=$(curl -s -w "%{http_code}" \
              --request PUT \
              --header "Authorization: Bearer $RENDER_API_KEY" \
              --header "Content-Type: application/json" \
              --data "{\"value\":$VALUE_ESCAPED}" \
              --url "https://api.render.com/v1/env-groups/$ENV_GROUP_ID/env-vars/$ENCODED_KEY")
            HTTP_STATUS="${UPDATE_RESPONSE: -3}"
            RESPONSE_BODY="${UPDATE_RESPONSE::-3}"
            if [ "$HTTP_STATUS" -ne 200 ]; then
              echo "Error: Failed to update env var $KEY. HTTP Status: $HTTP_STATUS"
              echo "Response: $RESPONSE_BODY"
              exit 3
            fi
            echo "Successfully updated env var $KEY."
          done

      - name: Get Last Workflow Run
        id: get-last-run
        if: steps.check-existing-deployment.outputs.EXISTING_DEPLOYMENT == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          WORKFLOW_ID: ${{ github.workflow }}
          BRANCH: ${{ github.ref_name }}
          CURRENT_RUN_ID: ${{ github.run_id }}
        run: |
          set -e
          # Get the workflow runs for this workflow and branch
          RESPONSE=$(curl -s \
            --request GET \
            --header "Authorization: Bearer $GITHUB_TOKEN" \
            --url "https://api.github.com/repos/${{ github.repository }}/actions/workflows/${{ github.workflow }}/runs?branch=${{ github.ref_name }}&status=completed&per_page=5")
          # Parse the runs and find the last run before the current one
          LAST_RUN_TIME=""
          RUNS=$(echo "$RESPONSE" | jq -c '.workflow_runs[]')
          for run in $RUNS; do
            RUN_ID=$(echo "$run" | jq -r '.id')
            if [ "$RUN_ID" -ne "${{ github.run_id }}" ]; then
              LAST_RUN_TIME=$(echo "$run" | jq -r '.updated_at')
              LAST_RUN_STATUS=$(echo "$run" | jq -r '.conclusion')
              break
            fi
          done
          if [ -z "$LAST_RUN_TIME" ]; then
            echo "No previous workflow run found."
            echo "::set-output name=OVERWRITE_ALLOWED::false"
            exit 0
          fi
          # Convert times to seconds since epoch
          LAST_RUN_TIMESTAMP=$(date -d "$LAST_RUN_TIME" +%s)
          CURRENT_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          CURRENT_TIMESTAMP=$(date -d "$CURRENT_TIME" +%s)
          TIME_DIFF=$(( CURRENT_TIMESTAMP - LAST_RUN_TIMESTAMP ))
          if [ "$TIME_DIFF" -lt 30 ]; then
            echo "The last workflow run was $TIME_DIFF seconds ago."
            echo "::set-output name=OVERWRITE_ALLOWED::true"
          else
            echo "The last workflow run was more than 30 seconds ago."
            echo "::set-output name=OVERWRITE_ALLOWED::false"
          fi
