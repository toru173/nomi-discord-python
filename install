: << END_WIN
@ECHO OFF
:: If this script is being run using curl it will need to save
:: itself to a temporary file. We do that here:
SET "TEMP_INSTALL_SCRIPT=%TEMP%\%RANDOM%-%RANDOM%-%RANDOM%-%RANDOM%.bat"
TIMEOUT /T 0 >NUL 2>NUL
IF ERRORLEVEL 1 (curl -sL https://raw.githubusercontent.com/toru173/nomi-discord-python/refs/heads/main/install -o %TEMP_INSTALL_SCRIPT% --remove-on-error && START /I /WAIT CMD /Q /K %TEMP_INSTALL_SCRIPT% & DEL /F /Q %TEMP_INSTALL_SCRIPT% & EXIT)
::
:: We need to set a temporary install file path before
:: the pipe-check because expansion behaves differently
:: when executing from a pipe. We also can't use a
:: TIMEOUT because it behaves differently when being piped.
:: We try to run it as a way to check that the script is
:: running from a pipe, but then use ping with a timeout
:: when we actually need to wait (https://stackoverflow.com/a/735294)
::
:: ============================================================================
:: === The LICENSE for this script can be found at the bottom of this file ====
:: ============================================================================
::
:: This is the Windows part of the script.

SETLOCAL ENABLEDELAYEDEXPANSION
SET INSTALL_FOLDER=nomi-discord-python
SET HOME_DIR=%USERPROFILE%

:: Perform a basic sanity check
IF NOT "%OS%" == "Windows_NT" (
    ECHO Windows NT is required
    GOTO cleanup
)

ECHO ===========================================================================
ECHO ============================ Easy Installer ===============================
ECHO ===========================================================================
ECHO:
ECHO Welcome to the easy installer for nomi-discord-python. We're going to check
ECHO that your system has a few things installed already, then install the latest
ECHO version of nomi-python-discord.
ECHO:
ECHO If you ever want to quit the script, simply press CTRL+C together
ECHO:

:: First, check for required dependencies. We need Docker for
:: this project to run, so check we have that installed. If
:: not, prompt the user to download it then re-run this script.
SET DOCKER_INSTALLED=0
SET TAR_INSTALLED=0

:: Check if Docker is installed
docker --version >NUL 2>&1
IF ERRORLEVEL 1 (
    SET DOCKER_INSTALLED=0
) ELSE (
    SET DOCKER_INSTALLED=1
)

:: Check if tar is installed. It SHOULD be because it shipped
:: with Windows before cURL, and this script is most likely
:: running using cURL.
tar --version >NUL 2>&1
IF ERRORLEVEL 1 (
    SET TAR_INSTALLED=0
) ELSE (
    SET TAR_INSTALLED=1
)

:: Display installation statuses
IF "%DOCKER_INSTALLED%" == "1" (
    ECHO [x] Docker is installed
) ELSE (
    ECHO [ ] Docker is not installed
)

IF "%TAR_INSTALLED%" == "1" (
    ECHO [x] tar is installed
) ELSE (
    ECHO [ ] tar is not installed
)

:: If both are installed, continue
IF "%DOCKER_INSTALLED%" == "1" IF "%TAR_INSTALLED%" == "1" (
    ECHO:
    ECHO All required software is installed.
) ELSE (

    :: We're missing some necessary software. Let's fix it.
    ECHO:
    ECHO Please install the missing software and re-run the installer.

    SET /P "INSTALL_HELP=Would you like help installing the missing software? [y/N]: "
    IF /I "!INSTALL_HELP!" == "Y" (
        IF "%DOCKER_INSTALLED%" == "0" (
            ECHO:
            ECHO Docker is required but not installed.
            SET /P "OPEN_BROWSER=Would you like to open the Docker download page now? [y/N]: "
            IF /I "!OPEN_BROWSER!" == "Y" (
                START https://www.docker.com/products/docker-desktop/
            )
        )
        IF "%TAR_INSTALLED%" == "0" (
            ECHO:
            ECHO tar is required but not installed. It was integrated into Windows 10 in 2018. Do you need to update?
            ECHO Alternatively tar can be installed by installing Git for Windows, which provides tar and other Unix tools.
            SET /P "OPEN_BROWSER=Would you like to open the Git for Windows download page now? [y/N]: "
            IF /I "!OPEN_BROWSER!" == "Y" (
                START https://git-scm.com/download/win
            )
        )
    )
    ECHO Some required software is missing. Please install the missing software and re-run the installer
    GOTO cleanup
)

:: Now we know know we have Docker and tar we check with the user if
:: installing in our default location (%USERPROFILE%\%INSTALL_FOLDER%)
:: is ok. If not, ask for an alternative.
:: Set default installation directory
SET "DEFAULT_INSTALL_DIR=%USERPROFILE%\%INSTALL_FOLDER%"
SET "INSTALL_DIR=%DEFAULT_INSTALL_DIR%"

ECHO:
ECHO Where would you like to install nomi-discord-python?

:prompt_install_dir
ECHO Current choice: %INSTALL_DIR%
SET /P "USER_INPUT=Enter to Accept > "

IF NOT "%USER_INPUT%" == "" SET "INSTALL_DIR=%USER_INPUT%"

:: Display the chosen directory and ask for confirmation
ECHO:
ECHO Your choice: %INSTALL_DIR%
SET /P "CONTINUE=Are you sure? [y/N]: "

IF /I NOT "!CONTINUE!" == "Y" (
    GOTO prompt_install_dir
)

ECHO:
ECHO Proceeding with installation in: %INSTALL_DIR%

:: Create the folder if it doesn't exist.
IF NOT EXIST "%INSTALL_DIR%" (
    MKDIR "%INSTALL_DIR%"
)

:: Generate a random file name using the %RANDOM% environment variable
SET "WRITE_TEST=%INSTALL_DIR%\%RANDOM%-%RANDOM%-%RANDOM%-%RANDOM%"

:: Check we have write access to the location the user has provided.
:: We'll try to create a test directory to check write access.
MKDIR "%WRITE_TEST%"
IF ERRORLEVEL 1 (
    ECHO It looks like we can't write to the folder: %INSTALL_DIR%.
    ECHO Please make sure you have permission to write to this directory and try again.
    GOTO cleanup
)

:: Delete the test directory after the check
RMDIR "%WRITE_TEST%"

:: Here we download the latest release from GitHub to INSTALL_FOLDER
ECHO Downloading the latest version from GitHub...
curl -L https://github.com/toru173/nomi-discord-python/archive/refs/heads/main.zip -o "%INSTALL_DIR%\install.zip" --progress-bar --remove-on-error
IF NOT EXIST "%INSTALL_DIR%\install.zip" (
    ECHO Something went wrong during the download. Please try again.
    GOTO cleanup
)

:: Warn the user that existing files will be overwritten. No going back now!
ECHO:
ECHO WARNING: This step will overwrite existing installation files in the directory:
ECHO %INSTALL_DIR%
ECHO:
ECHO Any configuration files or startup scripts should be safe; however, if
ECHO you are unsure, cancel now and save your files to a safe place before
ECHO proceeding.
ECHO:

:: Prompt the user before proceeding
SET /P CONTINUE="Are you sure you want to proceed with the installation? [y/N]: "
IF /I NOT "!CONTINUE!" == "Y" (
    ECHO Extraction canceled. No changes were made.
    GOTO cleanup
)

:: Proceed with unzipping the file using tar and overwrite existing files.
:: GitHub wraps the whole repository in a folder so we have to traverse
:: into that before before we can filter by the things we want to download.
:: After that, get the install script, the license and everything inside
:: the 'app' subdirectory
ECHO Extracting installation files...
tar -xvf "%INSTALL_DIR%\install.zip" -C "%INSTALL_DIR%" --strip-components=1 --include="*\install" --include="*\LICENSE" --include="*\app" 
IF ERRORLEVEL 1 (
    ECHO Failed to extract the installation files. Please try again.
    GOTO cleanup
)

IF EXIST "%INSTALL_DIR%\install.zip" DEL /F /Q "%INSTALL_DIR%\install.zip"

:: Check if the install script exists (it should). Rename it to
:: install.bat to make running it from the command line easier later
IF EXIST "%INSTALL_DIR%\install" (
    IF EXIST "%INSTALL_DIR%\install.bat" DEL /F /Q "%INSTALL_DIR%\install.bat"
    REN "%INSTALL_DIR%\install" "install.bat"
)

:: Check if the Nomi creation script exists (it should). Copy and rename it to
:: create_nomi.bat to make running it from the command line easier later
IF EXIST "%INSTALL_DIR%\app\create_nomi" (
    COPY /Y "%INSTALL_DIR%\app\create_nomi" "%INSTALL_DIR%\create_nomi.bat" >NUL
)

ECHO:
ECHO The installation completed succesfully.
ECHO:

:: Once everything unzipped we're good to go! Display a success message
:: to the user and ask if they want to set up any Nomis now. If the
:: user wants to set up a Nomi run the setup file in this directory
:: for them
IF EXIST "%INSTALL_DIR%\create_nomi.bat" (
    SET /P "CREATE_NOMI=Do you want to create a Nomi now? [y/N]: "
    ECHO "!CREATE_NOMI!"
    IF /I "!CREATE_NOMI!" == "Y" (
        ECHO Creating a new Nomi...
        START /I CMD /Q /K "%INSTALL_DIR%\create_nomi.bat"
    ) ELSE (
        ECHO Creating a new Nomi was skipped. You can run it later
        ECHO by running create_nomi.bat in the installation directory.
    )
)

ECHO:
SET /P "OPEN_FOLDER=Would you like to open the installation folder in a file browser? [y/N]: "
IF /I "!OPEN_FOLDER!" == "Y" (
    EXPLORER %INSTALL_DIR%
)

:: All done! Let's exit from the Windows part of the script
:cleanup
:: In case we received an error between downloading and extracting
:: the install files, delete them here
IF EXIST "%INSTALL_DIR%\install.zip" DEL /F /Q "%INSTALL_DIR%\install.zip"
ENDLOCAL
PAUSE
ECHO You may now close this window
EXIT /B
END_WIN

# This is the macOS/Linux part of the script. We have to do
# The same steps here, but in a way that works for Bash.

# By default, we'll install into a folder called
# "INSTALL_FOLDER" in their home folder
readonly INSTALL_FOLDER=nomi-discord-python

# Perform some basic sanity checks, then continue execution
if [ -z "${BASH_VERSION:-}" ]; then
    # Attempt to find Bash
    if command -v bash >/dev/null 2>&1; then
        # Re-execute the script with Bash by reading it from stdin if necessary
        if [ -t 0 ]; then
            # If the script is not being piped, re-execute the file with bash
            exec bash "$0" "$@"
        else
            # If the script is being piped (non-interactive), re-execute from stdin
            exec bash <(cat) "$@"
        fi
    else
        # Unable to find Bash. Exit with an error
        echo "Bash is required to run this script." >&2
        exit 1
    fi
fi

# Trap to function when we exit
trap "cleanup" EXIT INT

# Cleanup function
function cleanup() {
    exit_code=$?
    if [ -n "$INSTALL_DIR" ] && [ -f "$INSTALL_DIR/install.zip" ]; then
        rm "$INSTALL_DIR/install.zip"
    fi
    exit $exit_code
}

# Prompt for and confirm user input
prompt_confirm() {
    read -r -p "$1 [y/N] " RESPONSE </dev/tty
    case "$RESPONSE" in
        [yY][eE][sS]|[yY]) 
            true
            ;;
        *)
            false
            ;;
    esac
}

function get_script() {
    local source_file="$1"
    local destination_dir="$2"
    
    # Check if the source file exists
    if [ ! -f "$source_file" ]; then
        echo "Error: Source file '$source_file' not found!"
        return 1
    fi

    local base_filename="$(basename $source_file)"

    # Determine the destination file based on the OS
    if [ "$(uname -s)" == "Darwin" ]; then
        destination_file="${destination_dir}/${base_filename}.command"
    elif [ "$(uname -s)" == "Linux" ]; then
        destination_file="${destination_dir}/${base_filename}.sh"
    else
        echo "Error: Unsupported operating system '$(uname -s)'."
        return 1
    fi
    echo "#!/usr/bin/env bash" > "$destination_file"
    cat "$source_file" >> "$destination_file"
    chmod +x "$destination_file"
}

echo "==========================================================================="
echo "============================ Easy Installer ==============================="
echo "==========================================================================="
echo
echo "Welcome to the easy installer for nomi-discord-python. We're going to check"
echo "that your system has a few things installed already, then install the latest"
echo "version of nomi-python-discord."
echo
echo "If you ever want to quit the script, simply press CTRL+C together"
echo

# First, check for required dependencies. We need Docker for
# this project to run, so check we have that installed. If
# not, prompt the user to download it then re-run this script.
DOCKER_INSTALLED=0
TAR_INSTALLED=0

# Check if Docker is installed
if command -v docker >/dev/null 2>&1; then
    DOCKER_INSTALLED=1
else
    DOCKER_INSTALLED=0
fi

# Check if tar is installed
if command -v tar >/dev/null 2>&1; then
    TAR_INSTALLED=1
else
    TAR_INSTALLED=0
fi

# Display installation statuses
if [ "$DOCKER_INSTALLED" -eq 1 ]; then
    echo "[x] Docker is installed"
else
    echo "[ ] Docker is not installed"
fi

if [ "$TAR_INSTALLED" -eq 1 ]; then
    echo "[x] tar is installed"
else
    echo "[ ] tar is not installed"
fi

# If both are installed, continue
if [ "$DOCKER_INSTALLED" -eq 1 ] && [ "$TAR_INSTALLED" -eq 1 ]; then
    echo
    echo "All required software is installed."
else
    # We're missing some necessary software. Let's fix it.
    echo
    echo "Please install the missing software and re-run the installer."

    # Prompt user for help installing the missing software
    if prompt_confirm "Would you like help installing the missing software?"; then
        # If Docker is not installed, prompt to open the Docker download page
        if [ "$DOCKER_INSTALLED" -eq 0 ]; then
            echo
            echo "Docker is required but not installed."
            if prompt_confirm "Would you like to open the Docker download page now?"; then
                # Attempt to open the browser with xdg-open (Linux) or open (macOS)
                if command -v xdg-open >/dev/null 2>&1; then
                    xdg-open "https://www.docker.com/products/docker-desktop/"
                elif command -v open >/dev/null 2>&1; then
                    open "https://www.docker.com/products/docker-desktop/"
                else
                    echo "Please manually open the following URL: https://www.docker.com/products/docker-desktop/"
                fi
            fi
        fi

        # Check if tar is installed. Prompt the user to download it if not
        # by attempting to guess what package manager they are using (if any)
        if [ "$TAR_INSTALLED" -eq 0 ]; then
            echo
            echo "tar is required but not installed."
            echo "You may need to install it using a package manager."
            echo

            # Provide examples of how to install tar depending on the system
            if command -v apt >/dev/null 2>&1; then
                echo "For Ubuntu or Debian-based systems, you can install tar by running:"
                echo "    sudo apt update && sudo apt install tar"
            elif command -v yum >/dev/null 2>&1; then
                echo "For Red Hat, CentOS, or Fedora systems, you can install tar by running:"
                echo "    sudo yum install tar"
            elif command -v dnf >/dev/null 2>&1; then
                echo "For newer Fedora systems (or RHEL 8+), you can install tar by running:"
                echo "    sudo dnf install tar"
            elif command -v zypper >/dev/null 2>&1; then
                echo "For SUSE or openSUSE systems, you can install tar by running:"
                echo "    sudo zypper install tar"
            elif command -v brew >/dev/null 2>&1; then
                echo "For macOS users, you can install GNU tar by running:"
                echo "    brew install gnu-tar"
            else
                echo "Your system does not have a recognized package manager."
                echo "Please refer to your system documentation on how to install tar."
            fi
        fi
    fi
    exit 1
fi

echo
echo "Where would you like to install nomi-discord-python?"

# Now we know we have Docker and tar we check with the user if
# installing in our default location ($HOME/$INSTALL_FOLDER) is ok.
# If not, ask for an alternative.
DEFAULT_INSTALL_DIR="$HOME/$INSTALL_FOLDER"
while true; do
    # Prompt the user for the installation directory
    echo "Current choice: $DEFAULT_INSTALL_DIR"
    read -p "Enter to Accept > " INSTALL_DIR </dev/tty
    INSTALL_DIR=${INSTALL_DIR:-$DEFAULT_INSTALL_DIR}
    
    # Display the chosen directory and ask for confirmation
    echo
    echo "Your choice: $INSTALL_DIR"
    if prompt_confirm "Are you sure?"; then
        break
    fi
done

echo
echo "Proceeding with installation in: $INSTALL_DIR"

# Create the folder if it doesn't exist.
if [ ! -d "$INSTALL_DIR" ]; then
    mkdir -p "$INSTALL_DIR"
fi

# Generate a random file name using the %$RANDOM environment variable
WRITE_TEST="${INSTALL_DIR}/$RANDOM-$RANDOM-$RANDOM-$RANDOM"

# Check we have write access to the location the user has provided.
# We'll try to create a test directory to check write access.
if ! mkdir "$WRITE_TEST" 2>/dev/null; then
    echo "It looks like we can't write to the folder: $INSTALL_DIR."
    echo "Please make sure you have permission to write to this directory and try again."
    exit 1
fi

# Delete the test directory after the check
rmdir "$WRITE_TEST"

# Download the latest release from GitHub to INSTALL_FOLDER
echo "Downloading the latest version from GitHub..."
curl -L https://github.com/toru173/nomi-discord-python/archive/refs/heads/main.zip -o "$INSTALL_DIR/install.zip" --progress-bar --remove-on-error

# Check if the download was successful
if [ ! -f "$INSTALL_DIR/install.zip" ]; then
    echo "Something went wrong during the download. Please try again."
    exit 1
fi

# Warn the user that existing files will be overwritten. No going back now!
echo
echo "WARNING: This step will overwrite existing installation files in the directory:"
echo "$INSTALL_DIR"
echo
echo "Any configuration files or startup scripts should be safe; however, if"
echo "you are unsure, cancel now and save your files to a safe place before"
echo "proceeding."
echo

# Prompt the user for confirmation to proceed
if ! prompt_confirm "Are you sure you want to proceed with the installation?"; then
    echo "Extraction canceled. No changes were made."
    # Cleanup and exit
    exit 0
fi


# Proceed with unzipping the file using tar and overwrite existing files.
# GitHub wraps the whole repository in a folder so we have to traverse
# into that before before we can filter by the things we want to download.
# After that, get the install script, the license and everything inside
# the 'app' subdirectory. GNU tar and bsdtar behave differently so we need
# to accomodate that
echo "Extracting installation files..."
if tar --version 2>&1 | grep -q "GNU tar"; then
    tar -xvf "$INSTALL_DIR/install.zip" -C "$INSTALL_DIR" --strip-components=1 \
        --wildcards --no-anchored '*/install' '*/LICENSE' '*/app/*'
elif tar --version 2>&1 | grep -qi "bsdtar"; then
    tar -xvf "$INSTALL_DIR/install.zip" -C "$INSTALL_DIR" --strip-components=1 \
        --include="*/install" --include="*/LICENSE" --include="*/app/*"
else
    echo "Error: Unsupported version of tar detected."
    exit 1
fi

# Check if the extraction was successful
if [ $? -ne 0 ]; then
    echo "Failed to extract the installation files. Please try again."
    exit 1
fi

# Check if the install script exists (it should). Rename it to
# install.sh on linux and install.command on macOS to make running
# it from the command line easier later and add a shebang
if [ -f "$INSTALL_DIR/install" ]; then
    get_script "$INSTALL_DIR/install" "$INSTALL_DIR/"
    rm "$INSTALL_DIR/install"
else
    echo "Error: install script not found in $INSTALL_DIR."
fi

# Check if the Nomi creation script exists (it should). Copy it
# from the /app directory into our install directory and make it
# executable too
if [ -f "$INSTALL_DIR/app/create_nomi" ]; then
    get_script "$INSTALL_DIR/app/create_nomi" "$INSTALL_DIR"
else
    echo "Error: create_nomi script not found in $INSTALL_DIR/app."
fi

echo
echo "The installation completed successfully."
echo

# Once everything unzipped we're good to go! Display a success message
# to the user and ask if they want to set up any Nomis now. If the
# user wants to set up a Nomi run the setup file in this directory
# for them
if [ "$(uname -s)" == "Darwin" ]; then
    CREATE_NOMI_SCRIPT="$INSTALL_DIR/create_nomi.command"
elif [ "$(uname -s)" == "Linux" ]; then
    CREATE_NOMI_SCRIPT="$INSTALL_DIR/create_nomi.sh"
else
    echo "Error: Unsupported operating system '$(uname -s)'."
    return 1
fi

if [ -f "$CREATE_NOMI_SCRIPT" ]; then
    # Prompt the user to set up a Nomi
    if prompt_confirm "Do you want to create a Nomi now?"; then
        echo
        "$CREATE_NOMI_SCRIPT"
    else
        echo "Creating a new Nomi was skipped. You can run it later"
        echo "by executing 'create_nomi.sh' in the installation directory."
    fi
fi

if prompt_confirm "Would you like to open the installation folder in a file browser?"; then
    if command -v xdg-open >/dev/null 2>&1; then
        # Linux (xdg-open is available)
        xdg-open "$INSTALL_DIR"
    elif command -v open >/dev/null 2>&1; then
        # macOS (open is available)
        open "$INSTALL_DIR"
    fi
fi

echo "You may now close this window"
echo

# All done! Let's exit from the macOS/Linux part of the script
exit 0

===============================================================================
================================== LICENSE ====================================
===============================================================================

LICENSE

Copyright (c) 2024-present toru173 and contributors

Redistribution and use in source and binary forms, with or without 
modification, are permitted (subject to the limitations in the disclaimer 
below) provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, 
  this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, 
  this list of conditions and the following disclaimer in the documentation 
  and/or other materials provided with the distribution.
* Neither the name of the copyright holder nor the names of the contributors
  may be used to endorse or promote products derived from this software
  without specific prior written permission.

NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY 
THIS LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND 
CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT 
NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER 
OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.